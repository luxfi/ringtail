---
title: Cryptographic Theory
description: Mathematical foundations of linkable ring signatures and lattice-based cryptography
---

# Cryptographic Theory

## Overview

Ringtail combines two powerful cryptographic primitives: **linkable ring signatures** for privacy and **lattice-based cryptography** for post-quantum security. This unique combination provides both strong privacy guarantees and resistance to quantum attacks.

## Ring Signature Mathematics

### Schnorr Signature Foundation

Ringtail's ring signatures are based on the Schnorr signature scheme, which provides:
- **Simplicity**: Elegant mathematical structure
- **Security**: Proven secure under discrete logarithm assumption
- **Efficiency**: Fast signature generation and verification

#### Standard Schnorr Signature

For a message `m`, private key `x`, and public key `P = xG`:

1. **Sign**:
   - Choose random `k ∈ Zq`
   - Compute `R = kG`
   - Compute `e = H(R || P || m)`
   - Compute `s = k + ex`
   - Signature: `σ = (R, s)`

2. **Verify**:
   - Check: `sG = R + eP`

### Extension to Ring Signatures

Ring signatures extend Schnorr signatures to hide the signer among a ring of public keys.

#### Ring Signature Generation

Given:
- Message `m`
- Private key `xi` with public key `Pi`
- Ring of public keys `{P0, P1, ..., Pn-1}`

Algorithm:
```
1. Generate key image: I = xi * H(Pi)
2. For j ≠ i:
   - Choose random sj ∈ Zq
   - Choose random cj ∈ Zq
3. Choose random α ∈ Zq
4. Compute:
   - Li = αG
   - Ri = α * H(Pi)
5. For j = i+1, ..., n-1, 0, ..., i-1:
   - Lj = sjG + cjPj
   - Rj = sjH(Pj) + cjI
6. Compute challenge:
   c0 = H(m || L0 || ... || Ln-1 || R0 || ... || Rn-1)
7. Close the ring:
   ci = c0 - Σ(j≠i) cj
   si = α - cixi
8. Output: σ = (I, c0, s0, ..., sn-1)
```

#### Ring Signature Verification

Given signature `σ = (I, c0, s0, ..., sn-1)`:

```
1. For j = 0, ..., n-1:
   - Compute Lj' = sjG + cjPj
   - Compute Rj' = sjH(Pj) + cjI
2. Verify: c0 = H(m || L0' || ... || Ln-1' || R0' || ... || Rn-1')
```

### Linkability Property

The **key image** `I = x * H(P)` ensures linkability:
- Deterministic for a given private key
- Cannot be forged without knowledge of `x`
- Two signatures with the same `I` indicate double-signing

This property is crucial for preventing double-spending in cryptocurrency applications.

## Lattice-Based Cryptography

### Polynomial Rings

Ringtail leverages polynomial ring operations from the Lattice library:

#### Ring Definition
The ring `R = Z[X]/(X^n + 1)` where:
- `n` is a power of 2 (typically 2^12 to 2^14)
- Operations are performed modulo `q` (prime or power of prime)

#### Why Polynomial Rings?

1. **Efficiency**: NTT enables O(n log n) multiplication
2. **Security**: Based on Ring-LWE problem
3. **Structure**: Natural for threshold cryptography

### Number Theoretic Transform (NTT)

NTT is the finite field analogue of FFT:

```
Forward NTT: a(X) → â = NTT(a)
Inverse NTT: â → a(X) = NTT^(-1)(â)
Multiplication: a(X) * b(X) = NTT^(-1)(NTT(a) ⊙ NTT(b))
```

Where `⊙` denotes component-wise multiplication.

### Ring-LWE Problem

The security of lattice operations is based on the Ring Learning With Errors (Ring-LWE) problem:

Given `(A, b = As + e)` where:
- `A` is a random polynomial matrix
- `s` is a secret polynomial vector
- `e` is a small error polynomial

It is computationally hard to recover `s`.

## Threshold Signatures

### Shamir Secret Sharing

Ringtail implements `(t, n)` threshold signatures using polynomial secret sharing:

#### Share Generation
For secret `s` and threshold `t`:
1. Generate random polynomial `f(x) = s + a₁x + ... + aₜ₋₁x^(t-1)`
2. Compute shares: `sᵢ = f(i)` for `i = 1, ..., n`
3. Any `t` shares can reconstruct `s` using Lagrange interpolation

#### Lagrange Interpolation
```
s = Σᵢ sᵢ * λᵢ
where λᵢ = Π(j≠i) (j/(j-i))
```

### Distributed Key Generation (DKG)

Ringtail supports distributed key generation without trusted dealer:

1. **Share Distribution**: Each party generates and distributes shares
2. **Verification**: Feldman VSS ensures share validity
3. **Aggregation**: Combine shares to form distributed key
4. **Threshold Signing**: `t` parties collaborate to sign

## Security Analysis

### Privacy Guarantees

#### Unconditional Anonymity
- **Information-theoretic hiding**: Even computationally unbounded adversary cannot identify signer
- **Perfect indistinguishability**: All ring members equally likely
- **Statistical distance**: Negligible between different signers

#### Unforgeability
Under the discrete logarithm assumption:
- Cannot forge signature without private key
- Cannot create valid key image without secret
- Collision-resistant hash functions prevent replay

### Quantum Resistance

#### Post-Quantum Security Levels

| Algorithm | Classical Security | Quantum Security |
|-----------|-------------------|------------------|
| Ring Signatures (256-bit) | 128 bits | 64 bits |
| Ring-LWE (n=4096, q≈2^128) | 256 bits | 128 bits |
| Hybrid Mode | 256 bits | 128 bits |

#### Quantum Attack Vectors

1. **Grover's Algorithm**: √n speedup for discrete log
   - Mitigation: Double key sizes

2. **Shor's Algorithm**: Polynomial time for discrete log
   - Mitigation: Lattice-based alternatives

3. **Hybrid Approach**: Combine classical and post-quantum
   - Current signatures remain valid
   - Future signatures gain quantum resistance

## Performance Analysis

### Computational Complexity

| Operation | Ring Signature | Lattice Operations |
|-----------|---------------|-------------------|
| Key Generation | O(1) | O(n log n) |
| Sign | O(r) | O(n log n) |
| Verify | O(r) | O(n log n) |
| Key Image | O(1) | N/A |

Where:
- `r` = ring size
- `n` = polynomial degree

### Space Complexity

| Component | Size |
|-----------|------|
| Public Key | 32 bytes |
| Private Key | 32 bytes |
| Ring Signature | 32 + 32r bytes |
| Lattice Signature | ~10 KB |
| Key Image | 32 bytes |

### Benchmark Results

On Apple M1 Pro:
- **Ring Sign (16 members)**: 2.1 ms
- **Ring Verify (16 members)**: 1.8 ms
- **Lattice Sign**: 0.8 ms
- **Lattice Verify**: 0.4 ms
- **Hybrid Sign**: 2.9 ms
- **Hybrid Verify**: 2.2 ms

## Advanced Topics

### Bulletproofs Integration

Ringtail can be extended with Bulletproofs for:
- **Confidential amounts**: Hide transaction values
- **Range proofs**: Prove values are in valid range
- **Aggregation**: Combine multiple proofs

### Sublinear Ring Signatures

Future enhancement using techniques like:
- **LSAG**: Linkable Spontaneous Anonymous Group signatures
- **Omniring**: O(log n) verification time
- **RingCT 3.0**: Logarithmic size signatures

### Cross-Chain Privacy

Multi-ring signatures for:
- **Atomic swaps**: Private cross-chain exchanges
- **Bridge privacy**: Hide cross-chain transfers
- **Universal anonymity**: Single anonymity set across chains

## Implementation Considerations

### Side-Channel Protection

1. **Constant-time operations**: No data-dependent branches
2. **Memory access patterns**: Independent of secret data
3. **Power analysis**: Randomized computation order
4. **Cache timing**: Preload all ring members

### Random Number Generation

Critical for security:
```go
// Use crypto/rand for security-critical randomness
import "crypto/rand"

func generateNonce() (*big.Int, error) {
    max := new(big.Int).Sub(curve.N, big.NewInt(1))
    k, err := rand.Int(rand.Reader, max)
    if err != nil {
        return nil, err
    }
    return k, nil
}
```

### Error Handling

Proper error propagation without leaking information:
- Generic error messages
- Timing-independent error paths
- No correlation between errors and secrets

## References

### Academic Papers
1. "Linkable Spontaneous Anonymous Group Signature" - Liu et al.
2. "Ring Confidential Transactions" - Noether et al.
3. "Lattice-based Zero-Knowledge Proofs" - Lyubashevsky
4. "Post-Quantum Ring Signatures" - Torres et al.

### Standards
- NIST Post-Quantum Cryptography
- IETF Ring Signatures Draft
- ISO/IEC 29192-7 Lightweight Cryptography

### Implementation Resources
- Monero RingCT
- Lattice Cryptography Library
- Stanford IBE Implementation
- Microsoft SEAL Library